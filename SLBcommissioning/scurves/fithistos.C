//# Copyright 2020  Adri√°n Irles (IJCLab, CNRS/IN2P3)

#include "TFile.h"
#include "TCanvas.h"
#include "TPaveStats.h"
#include "TH1.h"
#include "TROOT.h"
#include "TRint.h"
#include "TStyle.h"
#include "TLegend.h"
#include "TString.h"
#include <iostream>
#include <fstream>
#include "TF1.h"
#include "TGraphErrors.h"
#include "TGraph.h"
#include "../conf_struct.h"

using namespace std;


float FirstZero(TGraphErrors *gr)
{


  int imax = TMath::LocMax(gr->GetN(),gr->GetY()); 
  Double_t xmax,ymax;
  gr->GetPoint(imax, xmax, ymax);

  //if(imax==0) return 0;

  for(int i=imax; i<gr->GetN(); i++) {
      gr->GetPoint(i, xmax, ymax);
      if(ymax<0.05) return xmax;
  }

  return 0;
  
}

TF1 *FitScurve(TGraphErrors *gr)
{
   
  double par1=0, par2=0, par3=0;

  int imax = TMath::LocMax(gr->GetN(),gr->GetY());
  int n=gr->GetN();
  double* x = gr->GetX();
  double* y = gr->GetX();

  double xmin = max(x[imax],x[n/3])-3;
  double xmax = FirstZero(gr)+10;

  double ymax = y[imax];

  //  std::cout<<"  ----------- 1 "<<endl;

  TF1 *fit1 = new TF1("fit1","[0]*TMath::Erfc((x-[1])/(sqrt(2)*[2]))",xmin,xmax);

  fit1->SetParLimits(0,ymax*0.1,ymax*10);
  fit1->SetParLimits(1,190,250);

  fit1->SetParameter(0,ymax);
  fit1->SetParameter(1,200);
  fit1->SetParameter(2,3); 
  gr->Fit("fit1","QREM");

  par1=fit1->GetParameter(0); 
  par2=fit1->GetParameter(1); 
  par3=fit1->GetParameter(2);


  // std::cout<<par1<<" "<<par2<<" "<<par3<<endl;

  //  std::cout<<"  ----------- 2 "<<endl;

  if(par2<180) par2=200;
  if(par3<1) par3=1.5;
  xmin=max(par2-8*par3,x[n/3]);
  xmax=par2+20*par3;
  TF1 *fit2 = new TF1("fit2","[0]*TMath::Erfc((x-[1])/[2]+[3])",xmin,xmax);


  fit2->SetParLimits(0,par1*0.3,par1+par1*0.5);
  fit2->SetParLimits(1,190,240);
  fit2->SetParLimits(2,2,6);

  /* fit2->SetParameter(0,0.5*ymax);
  fit2->SetParameter(1,200);
  fit2->SetParameter(2,10); */
  fit2->SetParameter(0,par1);
  fit2->SetParameter(1,par2);
  fit2->SetParameter(2,par3);
  gr->Fit("fit2","QERM");
    
  return fit2;
}


std::vector<double> MeanSigma(TGraph *scurve_threshold, TString type="SK2a") {
  
  double mean=0;
  double sigma=0;
  int max=0;
  int min=1000000;
  double nch=0;
  for(int ichn=0; ichn<64; ichn++) {
    Double_t x,y;
    scurve_threshold->GetPoint(ichn, x, y);
    if(y<400) {
      mean +=  y;
      nch++;
    }
    if(y>max && y<400) max=y;
    if(y<min) min=y;
  }
  mean/=nch;
  for(int ichn=0; ichn<64; ichn++) {
    Double_t x,y;
    scurve_threshold->GetPoint(ichn, x, y);
    if(y<400) sigma +=  (y-mean)*(y-mean);
    // cout<<ichn<<" "<<y<<endl;
  }
  sigma = sqrt( sigma/63.);


  std::vector<double> result;

  
  if( (max-min)>15)  max=mean+sigma;
  if(type=="SK2") max=mean;
  result.push_back(max);

  // cout<<mean<<" "<<sigma<<" "<<max<< " "<<min<<endl;
  int th[64];
  for(int ichn=0; ichn<64; ichn++) {
    th[ichn]=0;
    Double_t x,y;
    scurve_threshold->GetPoint(ichn, x, y);
    if(y<max)th[ichn]=int(max-y);
    if(th[ichn]>15) th[ichn]=15;
    if(type=="SK2") th[ichn]=0;
    result.push_back(th[ichn]);

  }



  return result;

}

void fithistos(TString filename = "RateVsThresholdScan_02192020_SLBoard_test2", int nslabs=6, TString settings="../Run_Settings_", int iteration=0){

  read_configuration_file(TString::Format("%sit%i.txt",settings.Data(),iteration),false);

  TGraphErrors *scurve[15][16][64];
  TF1 *scurvefit[15][16][64];

  TFile *file_summary = new TFile("../scurves/histos/scurves_"+filename+".root" , "READ");
  file_summary->cd();

  for(int i=0; i<nslabs; i++) {
    for(int iasic=0; iasic<16; iasic++) {
      for(int ichn=0; ichn<64; ichn++) {
	scurve[i][iasic][ichn]=(TGraphErrors*)file_summary->Get(TString::Format("scurve_layer%i_chip%i_chn%i",i,iasic,ichn));
	scurvefit[i][iasic][ichn]=FitScurve(scurve[i][iasic][ichn]);
      }
    }
  }

  
  TGraph *scurve_mean[15][16];
  TGraph *scurve_width[15][16];
  TGraph *scurve_threshold[15][16];
  TGraph *scurve_offset[15][16];


  for(int i=0; i<nslabs; i++) {
    for(int iasic=0; iasic<16; iasic++) {
        double mean[64];
        double width[64];
        double threshold[64];
	double offset[64];
        double chn[64];

	for(int ichn=0; ichn<64; ichn++) {
	  mean[ichn]=-1;
	  width[ichn]=-1;
	  threshold[ichn]=-1;
	  offset[ichn]=-1;

	  chn[ichn]=ichn;
	  mean[ichn]=scurvefit[i][iasic][ichn]->GetParameter(1);
	  width[ichn]=scurvefit[i][iasic][ichn]->GetParameter(2);
	  threshold[ichn]=scurvefit[i][iasic][ichn]->GetParameter(1)+5*scurvefit[i][iasic][ichn]->GetParameter(2);
	  offset[ichn]=scurvefit[i][iasic][ichn]->GetParameter(3);

	}
	scurve_mean[i][iasic]= new TGraph(64,chn,mean);
	scurve_width[i][iasic]= new TGraph(64,chn,width);
	scurve_threshold[i][iasic]= new TGraph(64,chn,threshold);
	scurve_offset[i][iasic]= new TGraph(64,chn,offset);

    }
  }

  for(int i=0; i<nslabs; i++) {
    TString type="SK2";
    if(i==2 || i==4 || i==5) type="SK2a";			       
    for(int iasic=0; iasic<16; iasic++) {
      std::vector<double> mean_sigma = MeanSigma(scurve_threshold[i][iasic],type);
      double mean=mean_sigma.at(0);
      double fine_tuning[64];
      std::cout<<" -------------------------------------- "<< endl;
      std::cout<<"slab: "<<i<<" asic:"<<iasic<<"    TH:"<<mean<< endl;
      detector.slab[0][i].asu[0].skiroc[iasic].threshold_dac=mean;
      for(int ichn=0; ichn<64; ichn++) {
	fine_tuning[ichn]=mean_sigma.at(1+ichn);
	std::cout<<" chn:"<<ichn<<" TH -"<<fine_tuning[ichn]<<endl;
	detector.slab[0][i].asu[0].skiroc[iasic].chn_threshold_adj[ichn]=fine_tuning[ichn];
      }
    }
  }

  write_configuration_file(TString::Format("%sthresholds_it%i.txt",settings.Data(),iteration));
 
  
}





